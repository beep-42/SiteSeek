<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Protein Residue Selector</title>
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-LN+7fdVzj6u52u30Kp6M/trliBMCMKTyK833zpbD+pXdCLuTusPj697FH4R/5mcr" crossorigin="anonymous">
  <!-- NGL Viewer -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ngl/2.4.0/ngl.js"></script>
  <style>
    body { overflow-x: hidden; }
    #viewport { width: 100%; height: 70vh; border-radius: .5rem; }
    #output { overflow-y: auto; white-space: pre-wrap; }
    #jsonTableContainer table { 
      width: 100%; 
      border-collapse: collapse;
    }
    #jsonTableContainer th, 
    #jsonTableContainer td {
      padding: .5rem;
      border: 1px solid #dee2e6;
    }
    #jsonTableContainer tr:hover {
      background-color: #f1f3f5;
      cursor: pointer;
    }
  </style>
</head>
<body>

  <!-- Navbar -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-primary mb-3">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">Protein Search Tool</a>
    </div>
  </nav>

  <!-- Controls -->
  <div class="container mb-3">
    <div class="row g-2 align-items-center">
      <div class="col-auto">
        <label for="pdbId" class="col-form-label">PDB ID:</label>
      </div>
      <div class="col-auto">
        <input type="text" id="pdbId" class="form-control" value="1crn" style="width: 5rem;">
      </div>
      <div class="col-auto">
        <select id="database" class="form-select">
          {% for db in db_files %}
            <option value="{{ db }}">{{ db }}</option>
          {% endfor %}
        </select>
      </div>
      <div class="col-auto">
        <button id="loadBtn" class="btn btn-secondary">Load Structure</button>
        <button id="clearnBtn" class="btn btn-danger">Clear Selection</button>
        <button id="searchBtn" class="btn btn-primary">Search Selected <img style="height: 1em; color: white;" src="https://cdn-icons-png.flaticon.com/512/9807/9807442.png"></button>
      </div>
    </div>
  </div>

  <div class="container mb-3">
      <div class="col-auto">
        <span><strong>Selected:</strong> <span id="selection">None</span></span>
      </div>
  </div>

  <div class="container mb-3">
    <div class="progress" style="height: 1.5rem;">
      <div id="searchProgress"
          class="progress-bar progress-bar-striped progress-bar-animated"
          role="progressbar"
          style="width: 0%"
          aria-valuemin="0"
          aria-valuemax="100"
      >0%</div>
    </div>
  </div>

 <!-- Main Content -->
  <div class="container-fluid">
    <div class="row">
      <!-- Viewer -->
      <div class="col-lg-8 mb-3">
        <div id="viewport" class="border rounded"></div>
      </div>
      <!-- Right Column: Controls + Log -->
      <div class="col-lg-4 mb-3">
        <!-- Viewer Controls Row -->
        <div class="card mb-2">
          <div class="card-header">
            Viewer Controls
          </div>
          <div class="card-body">
            <p><strong>Query:</strong> <span id="ctrlQuery">None</span></p>
            <p><strong>Overlay:</strong> <span id="ctrlOverlay">None</span></p>
            <div class="form-check form-switch mb-2">
              <input class="form-check-input" type="checkbox" id="toggleSelection" checked>
              <label class="form-check-label" for="toggleSelection">
                Show Selections
              </label>
            </div>
            <button id="clearOverlayBtn" class="btn btn-sm btn-warning">
              Clear Overlay
            </button>
          </div>
        </div>
        <!-- Hit Info Card -->
        <div id="hitDetailsCard" class="card mb-2" style="display: none;">
          <div class="card-header">
            Hit Details
          </div>
          <div class="card-body">
            <h5 class="card-title" id="hitTitle">Loadingâ€¦</h5>
            <p class="card-text">
              <strong>ID:</strong> <span id="hitId"></span><br>
              <strong>Score:</strong> <span id="hitScore"></span><br>
              <strong>RMSD:</strong> <span id="hitRmsd"></span><br>
              <strong>Mapping:</strong> <pre id="hitMapping" style="white-space: pre-wrap;"></pre>
            </p>
          </div>
        </div>
        <!-- Output Log Row -->
        <div id="output" class="border bg-dark text-light p-2 rounded" style="overflow-y: auto;">
        </div>
      </div>
    </div>
    <!-- Results Table -->
    <div class="row">
      <div id="jsonTableContainer" class="col-12 mt-3"></div>
    </div>
  </div>

  <!-- Toast Container -->
  <div class="position-fixed bottom-0 end-0 p-3" style="z-index: 11">
    <div id="toastContainer"></div>
  </div>

  <!-- Bootstrap 5 JS Bundle (includes Popper) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/js/bootstrap.bundle.min.js" integrity="sha384-ndDqU0Gzau9qJ1lfW4pNLlhNTkCfHzAVBReH9diLvGRem5+R9g2FzA8ZGN954O5Q" crossorigin="anonymous"></script>

  <script>


    let stage = new NGL.Stage("viewport", {
        backgroundColor: "white"
    });

    let selectionSet = new Set();
    let reprMap = {};

    let queryComp, hitComp;

    let currentlyLoadedPdbId;

    // disable zoom on click for atoms
    stage.mouseControls.remove('clickPick-left', NGL.MouseActions.movePick)

    // Handle window resizing
    window.addEventListener("resize", () => stage.handleResize(), false);

    // Elements
    const ctrlQuery   = document.getElementById("ctrlQuery");
    const ctrlOverlay = document.getElementById("ctrlOverlay");
    const toggleSel   = document.getElementById("toggleSelection");
    const clearOvBtn  = document.getElementById("clearOverlayBtn");

    const hitCard     = document.getElementById("hitDetailsCard");
    const hitIdEl     = document.getElementById("hitId");
    const hitScoreEl  = document.getElementById("hitScore");
    const hitRmsdEl   = document.getElementById("hitRmsd");
    const hitMappingEl= document.getElementById("hitMapping");
    const hitTitleEl  = document.getElementById("hitTitle");


    // Toast helper
    function showToast(message, type = 'info') {
        const toastId = 'toast' + Date.now();
        const toastHtml = `
        <div id="${toastId}" class="toast align-items-center text-bg-${type} border-0 mb-2" role="alert" aria-live="assertive" aria-atomic="true">
          <div class="d-flex">
            <div class="toast-body">${message}</div>
            <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
          </div>
        </div>
      `;
        document.getElementById('toastContainer').insertAdjacentHTML('beforeend', toastHtml);
        const toastEl = document.getElementById(toastId);
        const bsToast = new bootstrap.Toast(toastEl, {
            delay: 3000
        });
        bsToast.show();
    }


    // Load PDB and set up picking
    document.getElementById("loadBtn").addEventListener("click", async () => {

        selectionSet.clear();
        reprMap = {};
        ctrlOverlay.textContent = "None";

        updateSelectionDisplay();

        currentlyLoadedPdbId = document.getElementById("pdbId").value.trim(); // .toUpperCase();
        if (!currentlyLoadedPdbId) return;

        showToast('Loading ' + currentlyLoadedPdbId, 'secondary');

        // remove hit if shown
        if (hitComp) {
            hitComp.removeAllRepresentations();
            hitComp.dispose();
            hitComp = null;
        }

        // Load structure
        if (queryComp) queryComp.removeAllRepresentations();
        queryComp = await stage.loadFile(`rcsb://${currentlyLoadedPdbId}`, {
            defaultRepresentation: true
        });

        // add a "cartoon" representation to the structure component
        // comp.addRepresentation("spacefill", {colorScheme: "uniform"});
        queryComp.addRepresentation("cartoon", {
            aspectRatio: 3.0,
            scale: 1.5
        });

        queryComp.addRepresentation("licorice", {
            sele: "hetero and not ( water or ion )",
            multipleBond: true
        });

        // provide a "good" view of the structure
        queryComp.autoView();


        // Enable picking
        stage.signals.clicked.add((pickingProxy) => {
            if (pickingProxy && pickingProxy.atom && !pickingProxy.atom.hetero) {

                let resNo = pickingProxy.atom.residue.resno;
                let chain = pickingProxy.atom.chainname;
                let object_id = pickingProxy.atom.structure.id;
                let key = `${chain}_${resNo}`;

                // disable picking atoms of non-query structure
                if (object_id != currentlyLoadedPdbId) {
                    return;
                }

                if (selectionSet.has(key)) {
                    selectionSet.delete(key);
                    queryComp.removeRepresentation(reprMap[key]);
                } else {
                    selectionSet.add(key);
                    reprMap[key] = queryComp.addRepresentation("surface", {
                        sele: `${resNo}:${chain}`,
                        name: key,
                        color: "red",
                        scale: 3
                    });
                }
                updateSelectionDisplay();
            }
        });

        showToast(`Structure ${currentlyLoadedPdbId} loaded.`, 'success');
        ctrlQuery.textContent = currentlyLoadedPdbId;

    });

    // Toggle selection visibility
    toggleSel.addEventListener("change", () => {
        const visible = toggleSel.checked;
        for (let key in reprMap) {
          reprMap[key].setVisibility(visible);
        }
    });

    // Clear overlay button
    clearOvBtn.addEventListener("click", () => {
        if (hitComp) {
            hitComp.removeAllRepresentations();
            hitComp.dispose();
            hitComp = null;
            ctrlOverlay.textContent = "none";
            hitCard.style.display = "None";
            showToast("Overlay cleared", "warning");
        }
    });


    document.getElementById('clearnBtn').addEventListener("click", () => {
      selectionSet.forEach((key) => {
        queryComp.removeRepresentation(reprMap[key]);
      });
      selectionSet.clear();
      updateSelectionDisplay();
    });


    // Update selected list in UI
    function updateSelectionDisplay() {
        let list = Array.from(selectionSet).join(", ") || "None";
        document.getElementById("selection").textContent = list;
    }

    document.getElementById("searchBtn").addEventListener("click", async () => {
        let residues = Array.from(selectionSet);
        let database = document.getElementById("database").value;
        if (!currentlyLoadedPdbId || !database || residues.length === 0) {
            showToast("Specify PDB ID and select at least one residue.", "danger");
            return;
        }

        // Reset & show progress bar
        const progBar = document.getElementById("searchProgress");
        progBar.style.width = "0%";
        progBar.textContent = "0%";
        progBar.parentElement.style.display = "block";

        let outputEl = document.getElementById("output");
        outputEl.textContent = "";
        document.getElementById("searchBtn").disabled = true;

        showToast('Search started', 'info');

        let response = await fetch("/search", {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                database: database,
                pdb_id: currentlyLoadedPdbId,
                residues: residues
            })
        });

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";

        while (true) {
            const {
                value,
                done
            } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, {
                stream: true
            });

            // Process complete lines
            let lines = buffer.split("\n");
            buffer = lines.pop(); // last partial line remains in buffer

            for (let line of lines) {
                line = line.trim();
                if (!line) continue;

                // If the line is a float between 0 and 100, treat as progress
                const num = parseFloat(line);
                if (!isNaN(num) && num >= 0 && num <= 100) {
                    progBar.style.width = `${num}%`;
                    progBar.textContent = `${num.toFixed(1)}%`;
                    continue;
                }

                // Try parsing JSON
                let parsed;
                try {
                    parsed = JSON.parse(line);
                } catch {
                    parsed = null;
                }

                if (parsed && typeof parsed === "object") {
                    renderJsonTable(parsed);
                } else {
                    outputEl.textContent += line + "\n";
                    outputEl.scrollTop = outputEl.scrollHeight;
                }
            }
        }

        // Process any leftover buffer
        let leftover = buffer.trim();
        if (leftover) {
            try {
                const parsed = JSON.parse(leftover);
                renderJsonTable(parsed);
            } catch {
                outputEl.textContent += leftover + "\n";
            }
        }

        document.getElementById("searchBtn").disabled = false;
        progBar.parentElement.style.display = "none";

        showToast('Search complete', 'success')

    });

    function renderJsonTable(data) {
        const container = document.getElementById("jsonTableContainer");
        container.innerHTML = ""; // clear any existing table

        const ids = Object.keys(data);
        if (ids.length === 0) {
            container.textContent = "No JSON results.";
            return;
        }

        // Only these columns will be displayed
        const displayCols = ["score", "rmsd", "mapping"];

        // Create table
        const table = document.createElement("table");
        table.className = "table table-striped table-hover";

        // Header row
        const thead = table.createTHead();
        const headerRow = thead.insertRow();
        ["Index", "PDB ID", ...displayCols].forEach(colName => {
            const th = document.createElement("th");
            th.scope = "col";
            th.textContent = colName;
            headerRow.appendChild(th);
        });

        // Body rows
        const tbody = table.createTBody();
        ids.forEach(id => {
            const row = tbody.insertRow();
            row.style.cursor = "pointer";

            // ID cell
            let cell = row.insertCell();
            cell.textContent = id + " ";

            // PDB ID cell
            let pdbIdCell = row.insertCell();
            pdbIdCell.textContent = data[id]['structure_id'] + " ";

            // Create external link after the ID
            const entry = data[id];
            const pdbId = entry.structure_id;
            const a = document.createElement("a");
            a.href = `https://www.rcsb.org/structure/${pdbId}`;
            a.target = "_blank";
            a.rel = "noopener";
            a.style.marginLeft = "0.5rem";
            // Using a simple Unicode icon â†—
            a.textContent = "â†—";
            pdbIdCell.appendChild(a);

            // Selected columns
            displayCols.forEach(colName => {
                let c = row.insertCell();
                let val = data[id][colName];
                // For mapping object, stringify nicely
                c.textContent = (colName === "mapping" && typeof val === "object") ?
                    JSON.stringify(val) :
                    val;
            });

            // Add click handler if needed
            row.addEventListener("click", () => {
                superposeEntry(data[id]);
            });
        });

        container.appendChild(table);
    }

    // Superpose a selected entry over the query structure
    async function superposeEntry(entry) {
        if (!queryComp) {
            alert("Load a query structure first.");
            return;
        }

        // Remove previous hit
        if (hitComp) {
            hitComp.removeAllRepresentations();
            hitComp.dispose();
            hitComp = null;
        }

        showToast('Loading hit in viewer...', 'secondary')
        // Load hit structure
        hitComp = await stage.loadFile(`rcsb://${entry.structure_id}`);

        // Build a 4x4 transformation matrix
        const rot = entry.rotation; // [[r11,r12,r13],...]
        const trans = entry.translation; // [tx, ty, tz]
        // NGL uses column-major order for Matrix4.set:
        // m11, m21, m31, m41, m12, m22, ..., m44
        const m = new NGL.Matrix4().set(
            rot[0][0], rot[1][0], rot[2][0], trans[0],
            rot[0][1], rot[1][1], rot[2][1], trans[1],
            rot[0][2], rot[1][2], rot[2][2], trans[2],
            0, 0, 0, 1
        );

        // Apply the transform and add representation
        hitComp.addRepresentation("cartoon", {
            color: "lightgrey",
            opacity: 0.5
        });
        hitComp.setTransform(m);

        showToast('Hit loaded!', 'success')
        ctrlOverlay.textContent = entry.structure_id;

        fillHitInfo(entry);
    }

    async function fillHitInfo(entry) {
      // Basic fields
      hitIdEl.textContent      = entry.structure_id;
      hitScoreEl.textContent   = entry.score.toFixed(2);
      hitRmsdEl.textContent    = entry.rmsd.toFixed(2);
      hitMappingEl.textContent = JSON.stringify(entry.mapping, null, 2);

      // Fetch title/description from RCSB API
      hitTitleEl.textContent = "Loadingâ€¦";
      try {
        const resp = await fetch(
          `https://data.rcsb.org/rest/v1/core/entry/${entry.structure_id}`
        );
        const js = await resp.json();
        hitTitleEl.textContent = js.struct.title || "No title available";
      } catch {
        hitTitleEl.textContent = "Description unavailable";
      }

      // Show the card
      hitCard.style.display = "block";
  }

  </script>

</body>
</html>
